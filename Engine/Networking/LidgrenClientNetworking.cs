using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

using Microsoft.Xna.Framework;
using Lidgren.Network.Xna;
using Lidgren.Network;

using Mammoth.Engine.Input;
using Mammoth.Engine.Audio;
using Mammoth;

namespace Mammoth.Engine.Networking
{
    /// <summary>
    /// Networking system for the client side. Allows for sending and receiving messages
    /// to and from the server, as well as for connecting to and disconnecting from a
    /// server.
    /// </summary>
    public class LidgrenClientNetworking : LidgrenNetworking, IClientNetworking
    {
        // A unique ID for this client, given by the server
        private int _clientID;

        private NetClient _client;
        private Queue<DataGram> _toSend;

        /// <summary>
        /// Creates the client networking system by initializing
        /// the lidgren client components and the queue of things
        /// to send.
        /// </summary>
        /// <param name="game"></param>
        public LidgrenClientNetworking(Game game)
            : base(game)
        {
            _toSend = new Queue<DataGram>();
            NetConfiguration config = new NetConfiguration("Mammoth");
            _client = new NetClient(config);
        }

        #region Events

        public event EventHandler EndGameEvent;

        #endregion

        #region IClientNetworking Members

        /// <summary>
        /// Queues up an Encodable object to be sent by placing it
        /// in a DataGram and adding it to the queue to send.
        /// </summary>
        /// <param name="toSend"></param>
        public void sendThing(IEncodable toSend)
        {
            if (toSend is BaseObject)
            {
                // If the thing to send is an object, include its ID in the message
                _toSend.Enqueue(new DataGram(toSend.GetType().ToString(), ((BaseObject)toSend).ID, toSend.Encode()));
            }
            else
            {
                // Otherwise, the thing doesn't have an ID (probably an InputState), so don't include one
                _toSend.Enqueue(new DataGram(toSend.GetType().ToString(), toSend.Encode()));
            }
        }

        /// <summary>
        /// Starts by queuing up the current InputState to be sent.
        /// Then sends everything in the queue of DataGrams to be
        /// sent. Finally, reads in all messages received in this
        /// update cycle, calling the appropriate handle methods
        /// on them.
        /// </summary>
        /// <param name="gameTime"></param>
        public override void Update(GameTime gameTime)
        {
            if (_client == null || _client.Status != NetConnectionStatus.Connected)
                return;
            base.Update(gameTime);

            // Send everything in the queue
            while (_toSend.Count != 0)
                sendMessage(_toSend.Dequeue());

            // Read in all new messages
            NetBuffer buffer = _client.CreateBuffer();
            NetMessageType type;
            while (_client.ReadMessage(buffer, out type))
            {
                switch (type)
                {
                    case NetMessageType.DebugMessage:
                        Console.WriteLine(buffer.ReadString());
                        break;
                    case NetMessageType.StatusChanged:
                        handleStatusChange(buffer);
                        break;
                    case NetMessageType.Data:
                        handleData(buffer);
                        break;
                }
            }
        }

        /// <summary>
        /// Send a message (in the form of a datagram). All messages
        /// are sent to the server. Writes the info from the datagram
        /// into a buffer and sends the buffer.
        /// </summary>
        /// <param name="message"></param>
        private void sendMessage(DataGram message)
        {
            NetBuffer buffer = _client.CreateBuffer();
            buffer.WriteVariableInt32(_clientID);
            buffer.WriteVariableInt32((int)MessageType.ENCODABLE);
            buffer.Write(message.ObjectType);
            // The server will have to determine whether to read in
            // and ID based on the object type written above
            if (message.ID >= 0)
                buffer.WriteVariableInt32(message.ID);
            buffer.WriteVariableInt32(message.Data.Length);
            buffer.WritePadBits();
            buffer.Write(message.Data);
            if (_client.Status == NetConnectionStatus.Connected)
                _client.SendMessage(buffer, NetChannel.ReliableInOrder1);
        }

        /// <summary>
        /// Handles status changes generated by Lidgren, at the moment
        /// by just printing them out.
        /// TODO: make this do more?
        /// </summary>
        /// <param name="buffer"></param>
        private void handleStatusChange(NetBuffer buffer)
        {
            string statusMessage = buffer.ReadString();
            NetConnectionStatus newStatus = (NetConnectionStatus)buffer.ReadByte();
            Console.WriteLine("New status for the server: " + newStatus + " (" + statusMessage + ").");
            switch (newStatus)
            {
                case NetConnectionStatus.Disconnected:
                case NetConnectionStatus.Disconnecting:
                    // If the server disconnected, shut down the client
                    Console.WriteLine("The server has disconnected.");
                    if (this.EndGameEvent != null)
                        this.EndGameEvent(this, new EventArgs());
                    break;
            }
        }

        /// <summary>
        /// Handles a Data packet, which could be an encodable or 
        /// a application-level status change message or an event. Encodables are 
        /// sent to the decoder, while status changes and events are handled appropriately.
        /// </summary>
        /// <param name="buffer"></param>
        private void handleData(NetBuffer buffer)
        {
            // Get the message type
            MessageType type = (MessageType)buffer.ReadVariableInt32();
            handleData(buffer, type);
        }

        /// <summary>
        /// Handles a Data packet with a known type, which could be an encodable or 
        /// a application-level status change message or an event. Encodables are 
        /// sent to the decoder, while status changes and events are handled appropriately.
        /// </summary>
        /// <param name="buffer"></param>
        private void handleData(NetBuffer buffer, MessageType type)
        {
            switch (type)
            {
                case MessageType.ENCODABLE:
                    // Encodables are read in and sent to the decoder
                    string objectType = buffer.ReadString();
                    int id = buffer.ReadVariableInt32();
                    int length = buffer.ReadVariableInt32();
                    buffer.SkipPadBits();
                    byte[] data = buffer.ReadBytes(length);
                    IDecoder decode = (IDecoder)this.Game.Services.GetService(typeof(IDecoder));
                    decode.AnalyzeObjects(objectType, id, data);
                    break;
                case MessageType.STATUS_CHANGE:
                    switch (buffer.ReadString())
                    {
                        case "SERVER_QUIT":
                            // If the server quit, shut down the client
                            Console.WriteLine("The server has quit.");
                            _client.Shutdown("The server quit.");
                            break;
                    }
                    break;
                case MessageType.EVENT:
                    handleEvent(buffer);
                    break;
            }
        }

        /// <summary>
        /// Handles an event sent from the server.
        /// </summary>
        /// <param name="buffer"></param>
        private void handleEvent(NetBuffer buffer)
        {
            switch (buffer.ReadString())
            {
                case "Sound":
                    string toPlay = buffer.ReadString();
                    IAudioService audio = (IAudioService)this.Game.Services.GetService(typeof(IAudioService));
                    audio.playSound(toPlay);
                    break;
                case "PlayerLeft":
                    int playerID = int.Parse(buffer.ReadString()) << 25;
                    IModelDBService mdb = (IModelDBService)this.Game.Services.GetService(typeof(IModelDBService));
                    if (mdb.hasObject(playerID))
                        mdb.getObject(playerID).IsAlive = false;
                    break;
                case "Death":
                    int playerObjID = int.Parse(buffer.ReadString()) << 25;
                    IModelDBService modelDB = (IModelDBService)this.Game.Services.GetService(typeof(IModelDBService));
                    if (modelDB.hasObject(playerObjID))
                        ((Player)modelDB.getObject(playerObjID)).Die();
                    break;
                case "EndGame":
                    Console.WriteLine("EndGame event received");
                    quitGame();
                    if (this.EndGameEvent != null)
                        this.EndGameEvent(this, new EventArgs());
                    break;
            }
        }

        /// <summary>
        /// Searches for an active server by sending out discovery requests,
        /// then listening for responses from a server. Upon finding a server,
        /// connects and then waits for the server to send a ClientID.
        /// </summary>
        public void joinGame()
        {
            // Send out discovery requests
            _client.DiscoverLocalServers(PORT);
            NetBuffer buffer = _client.CreateBuffer();
            NetMessageType type;
            while (true)
            {
                // Listen for ServerDiscovered messages
                _client.ReadMessage(buffer, out type);
                switch (type)
                {
                    case NetMessageType.DebugMessage:
                        Console.WriteLine(buffer.ReadString());
                        break;
                    case NetMessageType.StatusChanged:
                        string statusMessage = buffer.ReadString();
                        NetConnectionStatus newStatus = (NetConnectionStatus)buffer.ReadByte();
                        Console.WriteLine("New status: " + newStatus + " (" + statusMessage + ")");
                        break;
                    case NetMessageType.ServerDiscovered:
                        // When a server is discovered, connect to it
                        Console.WriteLine("Discovered network");
                        _client.Connect(buffer.ReadIPEndPoint());
                        while (_client.Status != NetConnectionStatus.Connected) ;
                        Console.WriteLine("Connected to server");
                        while (true)
                        {
                            // Wait for the server to send a ClientID
                            buffer = _client.CreateBuffer();
                            NetMessageType type2;
                            while (!_client.ReadMessage(buffer, out type2)) ;
                            switch (type2)
                            {
                                case NetMessageType.Data:
                                    MessageType messageType = (MessageType)buffer.ReadVariableInt32();
                                    if (messageType != MessageType.CLIENT_ID)
                                    {
                                        handleData(buffer, messageType);
                                    }
                                    else
                                    {
                                        int id = buffer.ReadVariableInt32();
                                        _clientID = id;
                                        Console.WriteLine("My ID is: " + _clientID);
                                        return;
                                    }
                                    break;
                            }
                        }
                }
            }
        }

        /// <summary>
        /// Makes the client quit the game.
        /// </summary>
        public void quitGame()
        {
            Console.WriteLine("Quitting game.");
            _client.Disconnect("Player Quit");
            _toSend.Clear();
        }

        /// <summary>
        /// A unique ID for this client, given to the client
        /// by the server when the client first connects.
        /// </summary>
        public override int ClientID
        {
            get { return _clientID; }
        }

        #endregion

        /// <summary>
        /// Small storage class which stores an object to be sent
        /// in serialized form along with the type and ID.
        /// </summary>
        private class DataGram
        {
            public string ObjectType;
            public int ID;
            public byte[] Data { get; set; }

            /// <summary>
            /// Constructs a DataGram for an object with an ID.
            /// </summary>
            /// <param name="objectType"></param>
            /// <param name="id"></param>
            /// <param name="data"></param>
            public DataGram(string objectType, int id, byte[] data)
            {
                ObjectType = objectType;
                ID = id;
                Data = data;
            }

            /// <summary>
            /// Constructs a DataGram for an event (or InputState) without an ID.
            /// </summary>
            /// <param name="objectType"></param>
            /// <param name="data"></param>
            public DataGram(string objectType, byte[] data)
            {
                ObjectType = objectType;
                ID = -1;
                Data = data;
            }
        }
    }
}
